## 位运算（机器值-> 原码反码补码-> 逻辑运算）

1. 首先，了解机器数和真值：
	- 一个数在计算机中的二进制表示形式，叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号，正数为0，负数为1。比如，十进制中的数 +3，计算机字长为8位，转换成二进制就是00000011。如果是 -3，就是 10000011。那么，这里的 00000011 和 10000011 就是机器数。
	- 因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1

1. 关于原码、反码和补码
	+ 原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:

			[+1]原 = 0000 0001

			[-1]原 = 1000 0001

			第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:
			[1111 1111，0111 1111]，即[-127，127]

	- 正数的反码是其本身，负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.

			[+1] = [00000001]原 = [00000001]反

			[-1] = [10000001]原 = [11111110]反

			可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算。
	- 正数的补码就是其本身，负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。(即在反码的基础上+1)

			[+1] = [00000001]原 = [00000001]反 = [00000001]补

			[-1] = [10000001]原 = [11111110]反 = [11111111]补

			对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.
	+ 深入理解：

				计算机可以有三种编码方式表示一个数。对于正数因为三种编码方式的结果都相同:
						
			[+1] = [00000001]原 = [00000001]反 = [00000001]补
			
				所以不需要过多解释. 但是对于负数:
			
			[-1] = [10000001]原 = [11111110]反 = [11111111]补
			
				可见原码，反码和补码是完全不同的。既然原码才是被人脑直接识别并用于计算表示方式，为何还会有反码和补码呢？
			
				首先，因为人脑可以知道第一位是符号位，在计算的时候我们会根据符号位，选择对真值区域的加减。(真值的概念在本文最开头)。
			
			但是对于计算机，加减乘数已经是最基础的运算，要设计的尽量简单。计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂！
			
				于是人们想出了将符号位也参与运算的方法。
			
			我们知道，根据运算法则减去一个正数等于加上一个负数，即: 1-1 = 1 + (-1) = 0，所以机器可以只有加法而没有减法，这样计算机运算的设计就更简单了。
			
				于是人们开始探索将符号位参与运算，并且只保留加法的方法。首先来看原码:计算十进制的表达式: 1-1=0
			
				1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2
			
				如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的。这也就是为何计算机内部不使用原码表示一个数。为了解决原码做减法的问题, 出现了反码:
			
			计算十进制的表达式: 1 - 1 = 0
			
				1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0
			
				我们发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在"0"这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的。
			
			而且会有[0000 0000]原和[1000 0000]原两个编码表示0。
			
				于是补码的出现, 解决了0的符号以及两个编码的问题:
			
				1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原这样0用[0000 0000]表示, 
			
			而以前出现问题的-0则不存在了。而且可以用[1000 0000]表示-128: (-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补
			
			-1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补码就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示。(对-128的补码
			
			表示[1000 0000]补算出来的原码是[0000 0000]，这是不正确的)
			
				使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数。 这就是为什么8位二进制，使用原码或反码表示的范围为[-127，+127]，而使用补码表示的
				
			范围为[-128，127]。
			
				因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-2^31，2^31-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值。

1. 常见操作
	- 左移操作：A << B
	
		将A的二进制表示的每一位向左移B位，左边超出的位截掉，右边不足的位补0
			
			A = 1100  B = 2
			A << B = 110000
	- 右移操作：A >> B，A >>> B
		
		右移操作分为算数右移和逻辑右移。算术右移是带符号的右移，逻辑右移是不带符号的右移。

			- 算术右移(Arithmetic Right Shift)：将A的二进制表示的每一位向右移B位，右边超出的位截掉，左边不足的位补符号位的数。

			- 逻辑右移(Logical Right Shift)：将A的二进制表示的每一位向右移B位，右边超出的位截掉，左边不足的位补0。

		C语言：只有逻辑右移 A >> B。JAVA 和 Python中：算术右移 A >> B , 逻辑右移 A >>> B

			A = 11111111111111111111111110000001
			B = 2
			A >> B = 11111111111111111111111111100000
			A >>> B = 00111111111111111111111111100000
	
	- 按位与操作A & B
		将A和B的二进制表示的每一位进行与操作，只有两个对应的二进制位都为1时，结果位才为1，否则为0.

			A = 001010
			B = 101100
			A & B = 001000
			e.g: 0&0=0;   0&1=0;    1&0=0;     1&1=1
	
	- 按位或操作A | B
		将A和B的二进制表示的每一位进行或操作，只要两个对应的二进制位有一个为1，结果位就为1，否则为0.

			A = 001010
			B = 101100
			A | B = 101110
			e.g: 0|0=0；   0|1=1；   1|0=1；    1|1=1
	
	- 按位非操作~A
		将A的二进制表示每一位进行取反操作，如果对应的二进制位为0，结果位为1，否则为0.

			A = 00000000000000000000000000001010
			~A = 11111111111111111111111111110101
	
	- 按位异或（XOR）操作A ^ B
		将A和B的二进制表示的每一位进行异或操作，如果对应的二进制位不同，结果位为1，否则为0.

			A = 001010
			B = 101100
			A ^ B = 100110
			e.g: 0^0=0；   0^1=1；   1^0=1；   1^1=0

1. Tricks:
	- 我们定义“1s”和“0s”分别为一系列1s或者0s。有如下规则：
	x ^ 0s = x    	
	x & 0s = 0s	    
	x | 0s = x 
	x ^ 1s = ~x 	
	x & 1s = x	    
	x | 1s = 1s
	x ^ x = 0s	 	
	x & x = x       
	x | x = x

	**Swap two numbers: a ^= b b ^= a a ^=b**  

1. LeetCode问题
    - **Trick 1: 利用n & (n - 1)消去n最后一位1**
		- [LeetCode 231](https://leetcode.com/problems/power-of-two/) **判断一个数是否为2的幂**
			+ 首先n在不为0的情况下，n如果为2的n次方，说明是（0000 0001）左移n次，n - 1为上述值减一，两者求与运算，最后结果为0.
			+ n > 0 && (n & (n - 1)) == 0
	
		- [LeetCode 191](https://leetcode.com/problems/number-of-1-bits/)**判断一个数二进制1的个数**
			+ 思考：1的个数取决于什么？
			+ 根据上题LeetCode 231每一次对于n和n - 1进行操作都是**对于n二进制数最后一位1进行消去**。E.g: 4 & 3为[0000 0100] & [0000 0011]。
			+ 故只需使用count来统计n不为0的时候n & (n - 1)的次数。
	
		- [LintCode 181](https://www.lintcode.com/problem/181/description)**如果将整数m转换为n需要操作多少次？**
			+ 思考：举例4和2的二进制分别为[0000 0100] [0000 0010]，我们需要变换几位呢？
			+ 结果为两位，即百位1需要变为0，十位0需要变为1，于是乎我们想到了异或（XOR）操作，然后只需要统计1的个数，回到之前的问题。
	
		- 拓展：找出数字n最右边的设置位的位置（最右边1的位置，例如4为[0000 0100]） --> (解答：首先，n为奇数，返回1。其次，首先n与(n - 1)求与，然后再与n求异或，即n = n ^ (n & (n - 1)))。最后只需要统计n右移的次数。[参考第二题](https://www.techiedelight.com/zh/bit-hacks-part-3-playing-rightmost-set-bit-number/)
		- 练手：[190. Reverse Bits](https://leetcode.com/problems/reverse-bits/)、[1009. Complement of Base 10 Integer](https://leetcode.com/problems/complement-of-base-10-integer/)

	- **Trick 2: 使用二进制进行子集枚举**
		- [LeetCode 78 or LintCode 17](https://www.lintcode.com/problem/17/solution/56500)**子集问题**
		- 具体思想是使用一个正整数二进制表示的第i位是1还是0，代表集合的第i个数取或者不取。所以从0到2^n-1总共2^n个整数，正好对应集合的2^n个子集。
		类似问题有[LeetCode 90:Subsets II]

	- **Trick 3: 利用a ^ b ^ b = a**
		- [LeetCode 268: Missing Number](https://leetcode.com/problems/missing-number/) 解法有：sort、HashSet、位运算、高斯求和
		- [82: 落单的数](https://www.lintcode.com/problem/82/)解答：0异或x = x，所以所有数异或一遍搞定。
		- [落单的数 II · Single Number II](https://www.jiuzhang.com/solutions/single-number-ii/)
		- [落单的数（三） · Single Number III](https://www.jiuzhang.com/problem/single-number-iii/)

	- Challenge:
		- [67. Add Binary](https://leetcode.com/problems/add-binary/)
		- [287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/): 如何使用O（n）时间复杂度不使用格外空间解决。
		- [29. Divide Two Integers](https://leetcode.com/problems/divide-two-integers/)
		- [371. Sum of Two Integers](https://leetcode.com/problems/sum-of-two-integers/solution/)
		- [318. Maximum Product of Word Lengths](https://leetcode.com/problems/maximum-product-of-word-lengths/)
		- [1386. Cinema Seat Allocation](https://leetcode.com/problems/cinema-seat-allocation/)
		